#!/usr/bin/perl

=head1 NAME

gofer - execute multiple ssh sessions in parallel

=head1 SYNOPSIS

    # This uses the file hosts.conf to define thie configuration,
    # and then reads and executes the commands in cmdfile on each host.
    gofer --config hosts.conf  cmdfile.

    # This checks for .gofer.conf, $USER/.gofer.conf or
    # /etc/gofer.conf, and uses the first one available to define the
    # ssh connections, and then executes the commands defied in
    # cmdfile on each host.  If this or the connections config is not
    # found, it will exit with an error.
    gofer cmdfile  

=head1 DESCRIPTION

This script will log in and execute commands on remote ssh servers.

It is WORK-IN-PROGRESS!  Expect rough edges.

=head1 CONNECTIONS DEFINITIONS

An example connections configuration file.

    # It can contain comments and blank lines
    host1   @host1

    host2   user2@host2
    host3   user3:password3@host3
    host4   user4@host4:873
    host5   user5:password5@host5:873

=head1 CMDFILE

An example command file:

    # It can contain comments and blank lines

    # normal commands are executed as the user logged in
    ls 

    # Multiple commands can be combined
    cd / ; ls
    grep /etc/hosts | cat >file

    # If the line starts with "sudo" then the rest of the line
    # is executed within a sudo shell
    sudo cd /root/configuration; git status

    # All commands are run under /bin/sh, which must be present for
    # things to work


=head1 EXAMPLE OUTPUT

An example showing what you might get invoking:

    ./gofer git-status.sh

With C<git-status.sh> containing:

   # bla de bla

   sudo cd /root/configuration; git status

And a C<.gofer.conf> containing:

    alpha    @alpha
    beta     @beta

Then you might get output like the following:
 

    ----[ alpha ]-----------------------------------------------------------
      # bla de bla

      $ sudo "cd /root/configuration; git status"
    # On branch WORK_IN_PROGRESS
    nothing to commit (working directory clean)

    ----(4s elapsed)

    ----[ beta ]------------------------------------------------------------
      # bla de bla

      $ sudo "cd /root/configuration; git status"
    # On branch BETA_LOCAL_MODS
    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #
    #	modified:   foo/src/stuff.h
    #
    no changes added to commit (use "git add" and/or "git commit -a")

    ----(4s elapsed)

    done

=cut

use strict;
use warnings;
use Getopt::Long qw(:config posix_default);
use Carp qw(croak);
use IO::File;
use List::Util qw(first);
use FindBin '$Bin';
use lib "$Bin/../local-lib/lib/perl5", "$Bin/../local-lib/lib/perl5/i486-linux-gnu-thread-multi", 
    "$Bin/../lib";

use Net::SSH::Mechanize::Multi;
#use Net::SSH::Mechanize::Parse qw(parse_map);
use Carp qw(croak);

sub slurp {
    my ($file) = @_;
    my $fh = IO::File->new($file)
        or croak "failed to open $file: $!";
    local $/;
    return <$fh>;
}

=head2 parse_map @lines_or_strings

Parses a sequence of lines of the following form:

    C<host   user:password@host:port>

Returns an array of C<<($name => \%params)>> pairs, each defining a
connection name and a parameter hash as accepted by
C<<Net::SSH::Mechanize::ConnectParams->new>>, which can be passed
directly to C<<Net::SSH::Mechanize::Multi->add>>.

=cut

sub parse_map {
    my @map;
    foreach my $str (@_) {
        foreach (split '\n', $str) {
            next if /^\s*#/;
            next if /^\s*$/;
            chomp;

            my ($name, $connection) = split ' ', $_, 2;

            my %params;
            @params{qw(user password host port)} = 
                $connection =~ m{^
                                 (?:
                                     ([^\s:]+)?
                                     (?:
                                         : (\S+)
                                     )?
                                 )?
                                 @
                                 (\S+?)
                                 (?:
                                     : (\d+)
                                 )?
                              $}x
                    or croak "invalid connection spec '$connection'\n";

            
            defined $params{$_} or delete $params{$_}
                for keys %params;
            
            push @map, $name, \%params;
        }
    }
    

    return @map;
}

my $config_path = first { -f } 
    "$Bin/.gofer.conf", 
    "$ENV{USER}/.gofer.conf",
    "/etc/gofer.conf";


GetOptions(
    "--config=s" => sub {
        my (undef, $val) = @_;
        die "no such file '$val'\n"
            unless -f $val;

        $config_path = $val;
    },
)
    or die "failed to parse options, stopping\n";

die "no config file found, stopping. please supply one with --config option.\n"
    unless defined $config_path;

my %map = parse_map slurp $config_path;


my $cmd_file = shift
    or die "please supply a command file. stopping.\n";


#use Data::Dumper; warn Dumper \%map; # DB
my $manager = Net::SSH::Mechanize::Multi->new;
$manager->add(%map);



sub execute_script {
    my $ssh = shift;

    my @results;
    LOOP: foreach my $str (@_) {
        foreach (split '\n', $str) {
            if (/^\s*#/ || /^\s*$/) {
                push @results, "  $_\n";
                next;
            }

            chomp;
            if (s/^\s*sudo\s*//) {
                
                push @results, qq(  \$ sudo "$_"\n);
                eval {
                    my $result = $ssh->sudo_capture($_);

                    push @results, "$result\n"
                        if $result;
                    1;
                } or do {
                    push @results, my $err = $@;
                    last LOOP;
                }
            }
            else {
                push @results, qq(  \$ $_\n);
                eval {
                    my $result = $ssh->capture($_);

                    push @results, "$result\n"
                        if $result;
                    1;
                } or do {
                    push @results, my $err = $@;
                    last LOOP;
                }

            }
        }
    }
    return \@results;
}


my $cmds = slurp $cmd_file;

my $threads = $manager->in_parallel(keys %map => sub {
    my ($name, $ssh) = @_;
    my $start = time;

    my $results = execute_script $ssh, $cmds;

    print "----[ $name ]", '-'x(64 - length $name), "\n";
    print @$results;
    my $elapsed = time - $start;
    print "----(${elapsed}s elapsed)\n\n";
});

$_->join for @$threads;

print "done\n";
