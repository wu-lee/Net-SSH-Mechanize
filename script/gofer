#!/usr/bin/perl

=head1 NAME

gofer - execute multiple ssh sessions in parallel

=head1 SYNOPSIS

    # This uses the file hosts.conf to define thie configuration,
    # and then reads and executes the commands in cmdfile on each host.
    gofer --config hosts.conf  cmdfile.

    # This checks for .gofer.conf, $USER/.gofer.conf or
    # /etc/gofer.conf, and uses the first one available to define the
    # ssh connections, and then executes the commands defied in
    # cmdfile on each host.  If this or the connections config is not
    # found, it will exit with an error.
    gofer cmdfile  

=head1 DESCRIPTION

This script will log in and execute commands on remote ssh servers.

It is WORK-IN-PROGRESS!  Expect rough edges.

=head1 CONNECTIONS DEFINITIONS

An example connections configuration file.

    # It can contain comments and blank lines
    host1   @host1

    host2   user2@host2
    host3   user3:password3@host3
    host4   user4@host4:873
    host5   user5:password5@host5:873

=head1 CMDFILE

An example command file:

    # It can contain comments and blank lines

    # normal commands are executed as the user logged in
    ls 

    # Multiple commands can be combined
    cd / ; ls
    grep /etc/hosts | cat >file

    # If the line starts with "sudo" then the rest of the line
    # is executed within a sudo shell
    sudo cd /root/configuration; git status

    # All commands are run under /bin/sh, which must be present for
    # things to work


=head1 EXAMPLE OUTPUT

An example showing what you might get invoking:

    cat hosts | gofer git-status.sh

With C<git-status.sh> containing:

   # bla de bla

   sudo cd /root/configuration; git status

And a C<hosts> containing:

    alpha    @alpha
    beta     @beta

Then you might get output like the following:
 

    ----[ alpha ]-----------------------------------------------------------
      # bla de bla

      $ sudo "cd /root/configuration; git status"
    # On branch WORK_IN_PROGRESS
    nothing to commit (working directory clean)

    ----(4s elapsed)

    ----[ beta ]------------------------------------------------------------
      # bla de bla

      $ sudo "cd /root/configuration; git status"
    # On branch BETA_LOCAL_MODS
    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #
    #	modified:   foo/src/stuff.h
    #
    no changes added to commit (use "git add" and/or "git commit -a")

    ----(4s elapsed)

    done

=cut

use strict;
use warnings;
use Getopt::Long qw(:config gnu_compat);
use Carp qw(croak);
use IO::File;
use List::Util qw(first);
use FindBin '$Bin';
use lib "$Bin/../local-lib/lib/perl5", "$Bin/../local-lib/lib/perl5/i486-linux-gnu-thread-multi", 
    "$Bin/../lib";

use Carp qw(croak);

######################################################################

sub slurp {
    my ($file) = @_;
    my $fh = IO::File->new($file)
        or croak "failed to open $file: $!";
    local $/;
    return <$fh>;
}


# Prompt for a password, and read it directly from terminal (so that
# we can also read from stdin).  This won't work on non-unix systems,
# since they don't have /dev/tty.  I'm not sure what I should do
# there, presumably use Win32::Console?
# Adapted from
# http://perldoc.perl.org/perlfaq5.html#How-can-I-read-a-single-character-from-a-file?--From-the-keyboard?
# And http://www.perlmonks.org/?node_id=773803
sub prompt {
    my ($prompt) = @_;
    my $phrase = '';

    open my $tty, '<', '/dev/tty';
    local $| = 1;
    print $prompt;

    Term::ReadKey::ReadMode('noecho', $tty);

    while (1) {
        my $c = Term::ReadKey::ReadKey(~0/2-1, $tty); 
        # Windows workaround http://rt.cpan.org/Public/Bug/Display.html?id=27944

        if ($c =~ /[\r\n]/) {
            print "\n";
            last;
        }
        elsif ($c eq "\b" || ord $c == 127) {
            next unless length $phrase;
            chop $phrase;
        }
        elsif (ord $c) {
            $phrase .= $c;
        }
    }
    Term::ReadKey::ReadMode('restore', $tty);
    return $phrase;
}


# Stolen from Net::OpenSSH
my $obfuscate = sub {
    # just for the casual observer...
    my $txt = shift;
    $txt =~ s/(.)/chr(ord($1) ^ 47)/ges
        if defined $txt;
    $txt;
};
my $deobfuscate = $obfuscate;


# Constructors for the various password broker functions
my %password_brokers = (
    # Just interprets the token as the password in plaintext.
    # Maximally insecure.
    plaintext => sub { 
        return sub { shift },
    },

    # Interpret the token as a password obfuscated using $obfuscate
    obfuscated => sub { $deobfuscate },

    # Uses the token as a name to prompt the user for the *real* password.
    prompt => sub {
        require Term::ReadKey; # We must have this loaded.

        # keep the passwords here
        my %password_cache;

        return sub {
            my $token = shift;

            if (defined $password_cache{$token}) {
                return $password_cache{$token};
            }

            my $password = prompt "password for $token: ", echo => '*';

            return $password_cache{$token} = $password;
        };
    },
);


=head2 parse_map @lines_or_strings

Parses a sequence of lines of the following form:

    C<host   user:password@host:port>

Returns an array of C<<($name => \%params)>> pairs, each defining a
connection name and a parameter hash as accepted by
C<<Net::SSH::Mechanize::ConnectParams->new>>, which can be passed
directly to C<<Net::SSH::Mechanize::Multi->add>>.

=cut

sub parse_map {
    my @map;
    my $password_broker = shift;
    croak "first argument must be a coderef"
        unless ref $password_broker eq 'CODE';


    foreach my $str (@_) {
        foreach (split '\n', $str) {
            next if /^\s*#/;
            next if /^\s*$/;
            chomp;

            my ($name, $connection) = split ' ', $_, 2;

            my %params;
            @params{qw(user password host port)} = 
                $connection =~ m{^
                                 (?:
                                     ([^\s:]+)?
                                     (?:
                                         : (\S+)
                                     )?
                                 )?
                                 @
                                 (\S+?)
                                 (?:
                                     : (\d+)
                                 )?
                              $}x
                    or croak "invalid connection spec '$connection'\n";

            # Remove undefined values
            !defined $params{$_} and delete $params{$_}
                for keys %params;

            # Obtain the real password from our broker, if one exists.
            # This allows us to perform whatever sort of prompting,
            # look-up, or decryption we need, in a customisable way.
            if (exists $params{password}) {
                $params{password} = $password_broker->($params{password});
            }
            
            push @map, $name, \%params;
        }
    }
    

    return @map;
}


sub compile_script {
    my $sudos = 0;
    my @steps;

    foreach my $str (@_) {
        foreach (split '\n', $str) {
            my $line = $_;
            if (/^\s*#/ || /^\s*$/) {
                push @steps, sub { "  $line\n" };
                next;
            }

            chomp;
            if (s/^\s*sudo\s*//) {
                
                push @steps, sub { qq(  \$ sudo "$line"\n) };

                push @steps, sub { 
                    my $result = shift->sudo_capture($line);
                    return "$result\n"
                        if $result;
                };

                $sudos++;
            }
            else {
                push @steps, sub { qq(  \$ $line\n) };
                push @steps, sub {
                    my $result = shift->capture($line);

                    return "$result\n"
                        if $result;
                };
            }
        }
    }
    my $compiled = sub {
        my $ssh = shift;
        my @results;
        eval {
            foreach my $step (@steps) {
                push @results, $step->($ssh);
            }
            1;
        }
        or do {
            push @results, "$@"; 
        };
        return \@results;
    };

    return ($compiled, $sudos);
}


######################################################################

my $commands;
my $command_file;
my @credentials;
my $no_op;
my $password_broker = 'prompt';
GetOptions(
    "--no-op" => \$no_op,
    "--file=s" => sub {
        # FIXME can this be called twice?
        die "can't specify both --command and --file\n"
            if $commands;

        (undef, $command_file) = @_;
        die "no such file '$command_file'\n"
            unless -f $command_file;

        $commands = slurp $command_file;
    },
    "--password=s" => sub {
        (undef, $password_broker) = @_;
        die "No such password broker '$password_broker'\n"
            unless $password_brokers{$password_broker};
    },
    "--credentials=s" => sub {
        my (undef, $credentials_file) = @_;
        die "no such file '$credentials_file'\n"
            unless -f $credentials_file;

        @credentials = slurp $credentials_file;
    },
)
    or die "failed to parse options, stopping\n";

if ($command_file && @ARGV) {
    die "can't accept arguments if --file is given\n"
}
else {
    $commands = join " ", @ARGV;
}


# Construct the password broker.  This should generate an error if
# there is any problem.
$password_broker = $password_brokers{$password_broker}->();

die "Please supply some commands\n"
    unless $commands 
        && $commands =~ /\S/;

if ($no_op) {
    # just print the command.
    # FIXME print the hosts too?
    print "$commands\n";
    exit 0;
}

# Get credentials from STDIN if none already read
@credentials
    or @credentials = <STDIN>;

# Parse them, get passwords if required
my %map = parse_map $password_broker, @credentials;


# This module uses Moose and is a bit slow to start; don't start it
# unless we get this far.
require Net::SSH::Mechanize::Multi;

my $manager = Net::SSH::Mechanize::Multi->new;
$manager->add(%map);


my ($script, $sudos) = compile_script $commands;

my $threads = $manager->in_parallel(keys %map => sub {
    my ($name, $ssh) = @_;
    my $start = time;

    my $results = $script->($ssh);

    print "----[ $name ]", '-'x(64 - length $name), "\n";
    print @$results;
    my $elapsed = time - $start;
    print "----(${elapsed}s elapsed)\n\n";
});

$_->join for @$threads;

print "done\n";
